<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>经典窄颈圆头拼图 - 完整版</title>
    <style>
        body { background: #121212; color: #e0e0e0; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; display: flex; flex-direction: column; align-items: center; margin: 0; padding: 20px; }
        h2 { margin-bottom: 10px; color: #4CAF50; }
        .controls { background: #1e1e1e; padding: 15px 25px; border-radius: 12px; display: flex; gap: 15px; align-items: center; box-shadow: 0 4px 15px rgba(0,0,0,0.5); margin-bottom: 20px; }
        canvas { background: #252525; border: 2px solid #333; box-shadow: 0 0 40px rgba(0,0,0,0.8); cursor: grab; border-radius: 8px; }
        button { padding: 10px 18px; cursor: pointer; background: #4CAF50; color: white; border: none; border-radius: 6px; font-weight: 600; transition: transform 0.1s, background 0.2s; }
        button:hover { background: #45a049; transform: translateY(-1px); }
        button:active { transform: translateY(1px); }
        select { padding: 8px; border-radius: 6px; background: #333; color: white; border: 1px solid #444; }
    </style>
</head>
<body>

    <h2>经典窄颈圆头拼图</h2>
    <div class="controls">
        <label>阵列: <select id="gridSize">
            <option value="3">3 x 3</option>
            <option value="4" selected>4 x 4</option>
            <option value="5">5 x 5</option>
        </select></label>
        <button onclick="game.shuffle()">乱序排列</button>
        <button onclick="game.reset()">重新生成</button>
    </div>

    <canvas id="puzzleCanvas"></canvas>

<script>
/**
 * 参考 GitHub: yuesir/jigsaw-puzzle 核心逻辑实现 [cite: 11]
 * 涵盖：贝塞尔数学、过程化生成、游戏逻辑 [cite: 12, 15]
 */
class JigsawGame {
    constructor() {
        this.canvas = document.getElementById('puzzleCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.img = new Image();
        this.pieces = [];
        this.selected = null;
        
        this.img.onload = () => this.reset();
        // 选用具有丰富纹理的风景图以观察裁剪效果
        this.img.src = 'https://images.unsplash.com/photo-1501785888041-af3ef285b470?auto=format&fit=crop&w=1000&q=80';

        this.initEvents();
    }

    reset() {
        const size = parseInt(document.getElementById('gridSize').value);
        this.cols = size;
        this.rows = size;

        // 画布适配屏幕大小
        const maxDim = Math.min(window.innerWidth * 0.85, window.innerHeight * 0.6);
        const scale = Math.min(1, maxDim / Math.max(this.img.width, this.img.height));
        this.canvas.width = this.img.width * scale;
        this.canvas.height = this.img.height * scale;

        this.pw = this.canvas.width / this.cols;
        this.ph = this.canvas.height / this.rows;

        this.generateBoard(); // 对应教程 Section 3 [cite: 22]
        this.draw();
    }

    /**
     * 生成互锁的碎片网格
     */
    generateBoard() {
        this.pieces = [];
        // 存储边缘凹凸：0=平, 1=凸, -1=凹
        const vEdges = Array(this.cols + 1).fill(0).map(() => Array(this.rows).fill(0));
        const hEdges = Array(this.rows + 1).fill(0).map(() => Array(this.cols).fill(0));

        for (let i = 1; i < this.cols; i++) 
            for (let j = 0; j < this.rows; j++) vEdges[i][j] = Math.random() > 0.5 ? 1 : -1;
        for (let j = 1; j < this.rows; j++) 
            for (let i = 0; i < this.cols; i++) hEdges[j][i] = Math.random() > 0.5 ? 1 : -1;

        for (let r = 0; r < this.rows; r++) {
            for (let c = 0; c < this.cols; c++) {
                this.pieces.push({
                    c, r,
                    x: c * this.pw, y: r * this.ph,
                    correctX: c * this.pw, correctY: r * this.ph,
                    // 存储四边形状，确保相邻块匹配 [cite: 22]
                    edges: [hEdges[r][c], vEdges[c+1][r], hEdges[r+1][c], vEdges[c][r]],
                    locked: false
                });
            }
        }
    }

    /**
     * 核心：绘制窄颈圆头贝塞尔曲线 (Section 1 增强版) [cite: 18, 19]
     */
    drawBulbousTab(ctx, L, dir) {
        if (dir === 0) {
            ctx.lineTo(L, 0);
            return;
        }

        const h = L * 0.28 * dir; // 增加凸起高度系数
        
        // 极窄颈部比例 (0.46 - 0.54 = 8% 跨度)
        const pStart = L * 0.35; 
        const pNeck  = L * 0.46; 
        const pCenter = L * 0.50; 
        const pNeckEnd = L * 0.54; 
        const pEnd   = L * 0.65; 

        ctx.lineTo(pStart, 0);

        // 1. 进入窄颈 (控制点向内挤压)
        ctx.bezierCurveTo(pStart + L*0.05, 0, pNeck - L*0.01, h*0.05, pNeck, h*0.35);
        
        // 2. 圆润大头 (控制点横向大幅张开，纵向越过顶点)
        ctx.bezierCurveTo(pNeck - L*0.12, h*1.25, pNeckEnd + L*0.12, h*1.25, pNeckEnd, h*0.35);

        // 3. 返回边缘
        ctx.bezierCurveTo(pNeckEnd + L*0.01, h*0.05, pEnd - L*0.05, 0, pEnd, 0);

        ctx.lineTo(L, 0);
    }

    drawPiecePath(ctx, piece) {
        ctx.beginPath();
        ctx.moveTo(0, 0);

        // Top edge (反转方向以匹配上方块的凹凸)
        this.drawBulbousTab(ctx, this.pw, -piece.edges[0]);

        // Right edge
        ctx.save();
        ctx.translate(this.pw, 0); ctx.rotate(Math.PI / 2);
        this.drawBulbousTab(ctx, this.ph, piece.edges[1]);
        ctx.restore();

        // Bottom edge
        ctx.save();
        ctx.translate(this.pw, this.ph); ctx.rotate(Math.PI);
        this.drawBulbousTab(ctx, this.pw, piece.edges[2]);
        ctx.restore();

        // Left edge
        ctx.save();
        ctx.translate(0, this.ph); ctx.rotate(-Math.PI / 2);
        this.drawBulbousTab(ctx, this.ph, -piece.edges[3]);
        ctx.restore();

        ctx.closePath();
    }

    draw() {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        
        // 渲染排序：已锁定的块在底层，选中的在最顶层 [cite: 24]
        const renderList = [...this.pieces].sort((a,b) => {
            if (a === this.selected) return 1;
            if (b === this.selected) return -1;
            return a.locked ? -1 : 0;
        });

        renderList.forEach(p => {
            this.ctx.save();
            this.ctx.translate(p.x, p.y);

            this.drawPiecePath(this.ctx, p);
            
            // 裁剪与绘制 Section 2 
            this.ctx.save();
            this.ctx.clip();

            // 增加 Bleed 补偿，确保圆润大头不露白
            const bleed = this.pw * 0.45;
            const imgScale = this.img.width / this.canvas.width;

            this.ctx.drawImage(
                this.img,
                (p.correctX - bleed) * imgScale, (p.correctY - bleed) * imgScale,
                (this.pw + bleed * 2) * imgScale, (this.ph + bleed * 2) * imgScale,
                -bleed, -bleed, this.pw + bleed * 2, this.ph + bleed * 2
            );
            this.ctx.restore();

            // 描边效果
            this.ctx.strokeStyle = p.locked ? "rgba(255,255,255,0.1)" : "rgba(255,255,255,0.5)";
            this.ctx.lineWidth = 1.2;
            this.ctx.stroke();
            this.ctx.restore();
        });
    }

    // 交互逻辑部分 Section 4 [cite: 23]
    shuffle() {
        this.pieces.forEach(p => {
            p.x = Math.random() * (this.canvas.width - this.pw);
            p.y = Math.random() * (this.canvas.height - this.ph);
            p.locked = false;
        });
        this.draw();
    }

    initEvents() {
        this.canvas.onmousedown = (e) => {
            const rect = this.canvas.getBoundingClientRect();
            const mx = e.clientX - rect.left, my = e.clientY - rect.top;
            for (let i = this.pieces.length - 1; i >= 0; i--) {
                const p = this.pieces[i];
                if (p.locked) continue;
                if (mx > p.x && mx < p.x + this.pw && my > p.y && my < p.y + this.ph) {
                    this.selected = p;
                    this.dragOffX = mx - p.x;
                    this.dragOffY = my - p.y;
                    this.canvas.style.cursor = 'grabbing';
                    break;
                }
            }
        };

        window.onmousemove = (e) => {
            if (!this.selected) return;
            const rect = this.canvas.getBoundingClientRect();
            this.selected.x = e.clientX - rect.left - this.dragOffX;
            this.selected.y = e.clientY - rect.top - this.dragOffY;
            this.draw();
        };

        window.onmouseup = () => {
            if (!this.selected) return;
            const d = Math.sqrt(Math.pow(this.selected.x - this.selected.correctX, 2) + Math.pow(this.selected.y - this.selected.correctY, 2));
            if (d < 30) { // 磁吸效果 [cite: 24]
                this.selected.x = this.selected.correctX;
                this.selected.y = this.selected.correctY;
                this.selected.locked = true;
            }
            this.selected = null;
            this.canvas.style.cursor = 'grab';
            this.draw();
        };
    }
}

const game = new JigsawGame();
</script>
</body>
</html>