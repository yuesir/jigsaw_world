<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>经典扁平梨形拼图 - 完整版</title>
    <style>
        body { background: #1a1a1b; color: #f0f0f0; font-family: 'Inter', system-ui, sans-serif; display: flex; flex-direction: column; align-items: center; margin: 0; padding: 20px; }
        .header { text-align: center; margin-bottom: 20px; }
        .controls { background: #2d2d2e; padding: 20px 30px; border-radius: 16px; display: flex; gap: 20px; align-items: center; box-shadow: 0 8px 30px rgba(0,0,0,0.5); margin-bottom: 25px; border: 1px solid #3d3d3e; }
        canvas { background: #111; border: 1px solid #444; box-shadow: 0 0 50px rgba(0,0,0,0.9); cursor: grab; border-radius: 4px; }
        button { padding: 12px 24px; cursor: pointer; background: #3498db; color: white; border: none; border-radius: 8px; font-weight: 700; transition: all 0.2s; text-transform: uppercase; letter-spacing: 1px; }
        button:hover { background: #2980b9; transform: translateY(-2px); box-shadow: 0 4px 12px rgba(52, 152, 219, 0.3); }
        select { padding: 10px; border-radius: 8px; background: #3d3d3e; color: white; border: 1px solid #555; outline: none; }
    </style>
</head>
<body>

    <div class="header">
        <h2>高级扁平梨形拼图系统</h2>
        <p style="color: #888; font-size: 0.9em;">基于 Bézier 曲线数学逻辑实现</p>
    </div>

    <div class="controls">
        <label>难度设定: <select id="gridSize">
            <option value="3">入门 (3x3)</option>
            <option value="4" selected>标准 (4x4)</option>
            <option value="5">进阶 (5x5)</option>
            <option value="6">挑战 (6x6)</option>
        </select></label>
        <button onclick="game.shuffle()">打乱碎片</button>
        <button onclick="game.reset()" style="background: #27ae60;">刷新画布</button>
    </div>

    <canvas id="puzzleCanvas"></canvas>

<script>
/**
 * 完整拼图游戏引擎
 * 逻辑参考：yuesir/jigsaw-puzzle 教程系列
 */
class JigsawGame {
    constructor() {
        this.canvas = document.getElementById('puzzleCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.img = new Image();
        this.pieces = [];
        this.selected = null;
        
        this.img.onload = () => this.reset();
        // 选用高分辨率风景图
        this.img.src = 'https://images.unsplash.com/photo-1470770841072-f978cf4d019e?auto=format&fit=crop&w=1200&q=80';

        this.initEvents();
    }

    reset() {
        const size = parseInt(document.getElementById('gridSize').value);
        this.cols = size;
        this.rows = size;

        // 画布尺寸动态适配
        const maxW = window.innerWidth * 0.85;
        const maxH = window.innerHeight * 0.65;
        const ratio = Math.min(maxW / this.img.width, maxH / this.img.height);
        
        this.canvas.width = this.img.width * ratio;
        this.canvas.height = this.img.height * ratio;

        this.pw = this.canvas.width / this.cols;
        this.ph = this.canvas.height / this.rows;

        this.createTiles(); // 对应教程 Section 3: 生成拼图板 
        this.draw();
    }

    /**
     * 生成互锁数据结构
     */
    createTiles() {
        this.pieces = [];
        const vEdges = Array(this.cols + 1).fill(0).map(() => Array(this.rows).fill(0));
        const hEdges = Array(this.rows + 1).fill(0).map(() => Array(this.cols).fill(0));

        for (let i = 1; i < this.cols; i++) 
            for (let j = 0; j < this.rows; j++) vEdges[i][j] = Math.random() > 0.5 ? 1 : -1;
        for (let j = 1; j < this.rows; j++) 
            for (let i = 0; i < this.cols; i++) hEdges[j][i] = Math.random() > 0.5 ? 1 : -1;

        for (let r = 0; r < this.rows; r++) {
            for (let c = 0; c < this.cols; c++) {
                this.pieces.push({
                    c, r,
                    x: c * this.pw, y: r * this.ph,
                    correctX: c * this.pw, correctY: r * this.ph,
                    edges: [hEdges[r][c], vEdges[c+1][r], hEdges[r+1][c], vEdges[c][r]],
                    locked: false
                });
            }
        }
    }

    /**
     * 核心：绘制扁平梨形贝塞尔曲线 
     * @param {number} L 边缘长度
     * @param {number} dir 方向 (1/-1)
     */
    drawPearTab(ctx, L, dir) {
        if (dir === 0) {
            ctx.lineTo(L, 0);
            return;
        }

        const h = L * 0.25 * dir; 
        
        // 关键点比例调整以实现“扁平梨形”
        const pStart = L * 0.36; 
        const pNeck  = L * 0.45;  // 极窄颈部起始
        const pCenter = L * 0.50; 
        const pNeckEnd = L * 0.55; // 极窄颈部结束
        const pEnd   = L * 0.64; 

        ctx.lineTo(pStart, 0);

        // 1. 窄颈切入：迅速收缩
        ctx.bezierCurveTo(pStart + L*0.04, 0, pNeck - L*0.01, h*0.02, pNeck, h*0.3);
        
        // 2. 扁平梨形头：控制点纵向压低 (h*1.05)，横向大幅拉宽 (L*0.18)
        // 这里的 L*0.18 的横向跨度远超颈部的 L*0.05 跨度，形成梨形
        ctx.bezierCurveTo(pNeck - L*0.18, h*1.05, pNeckEnd + L*0.18, h*1.05, pNeckEnd, h*0.3);

        // 3. 切回边缘
        ctx.bezierCurveTo(pNeckEnd + L*0.01, h*0.02, pEnd - L*0.04, 0, pEnd, 0);

        ctx.lineTo(L, 0);
    }

    drawPiecePath(ctx, piece) {
        ctx.beginPath();
        ctx.moveTo(0, 0);

        // 四边递归绘制
        this.drawPearTab(ctx, this.pw, -piece.edges[0]); // Top

        ctx.save();
        ctx.translate(this.pw, 0); ctx.rotate(Math.PI / 2);
        this.drawPearTab(ctx, this.ph, piece.edges[1]); // Right
        ctx.restore();

        ctx.save();
        ctx.translate(this.pw, this.ph); ctx.rotate(Math.PI);
        this.drawPearTab(ctx, this.pw, piece.edges[2]); // Bottom
        ctx.restore();

        ctx.save();
        ctx.translate(0, this.ph); ctx.rotate(-Math.PI / 2);
        this.drawPearTab(ctx, this.ph, -piece.edges[3]); // Left
        ctx.restore();

        ctx.closePath();
    }

    draw() {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        
        // 绘制层级：锁定的在下，选中的在上
        const renderList = [...this.pieces].sort((a,b) => {
            if (a === this.selected) return 1;
            if (b === this.selected) return -1;
            return a.locked ? -1 : 0;
        });

        renderList.forEach(p => {
            this.ctx.save();
            this.ctx.translate(p.x, p.y);

            this.drawPiecePath(this.ctx, p);
            
            this.ctx.save();
            this.ctx.clip(); // 对应教程 Section 2: 裁剪瓦片 

            // 出血位补偿，确保梨形大圆头边缘图像完整
            const bleed = this.pw * 0.5; 
            const imgScale = this.img.width / this.canvas.width;

            this.ctx.drawImage(
                this.img,
                (p.correctX - bleed) * imgScale, (p.correctY - bleed) * imgScale,
                (this.pw + bleed * 2) * imgScale, (this.ph + bleed * 2) * imgScale,
                -bleed, -bleed, this.pw + bleed * 2, this.ph + bleed * 2
            );
            this.ctx.restore();

            // 质感描边
            this.ctx.strokeStyle = p.locked ? "rgba(255,255,255,0.1)" : "rgba(255,255,255,0.4)";
            this.ctx.lineWidth = p.selected ? 2 : 1.2;
            this.ctx.stroke();
            this.ctx.restore();
        });
    }

    // 交互与算法 Section 4 [cite: 24]
    shuffle() {
        this.pieces.forEach(p => {
            p.x = Math.random() * (this.canvas.width - this.pw);
            p.y = Math.random() * (this.canvas.height - this.ph);
            p.locked = false;
        });
        this.draw();
    }

    initEvents() {
        const getMousePos = (e) => {
            const rect = this.canvas.getBoundingClientRect();
            return { x: e.clientX - rect.left, y: e.clientY - rect.top };
        };

        this.canvas.onmousedown = (e) => {
            const pos = getMousePos(e);
            for (let i = this.pieces.length - 1; i >= 0; i--) {
                const p = this.pieces[i];
                if (p.locked) continue;
                if (pos.x > p.x && pos.x < p.x + this.pw && pos.y > p.y && pos.y < p.y + this.ph) {
                    this.selected = p;
                    this.dragX = pos.x - p.x;
                    this.dragY = pos.y - p.y;
                    break;
                }
            }
        };

        window.onmousemove = (e) => {
            if (!this.selected) return;
            const pos = getMousePos(e);
            this.selected.x = pos.x - this.dragX;
            this.selected.y = pos.y - this.dragY;
            this.draw();
        };

        window.onmouseup = () => {
            if (!this.selected) return;
            // 磁吸判断
            const dist = Math.hypot(this.selected.x - this.selected.correctX, this.selected.y - this.selected.correctY);
            if (dist < 25) {
                this.selected.x = this.selected.correctX;
                this.selected.y = this.selected.correctY;
                this.selected.locked = true;
            }
            this.selected = null;
            this.draw();
        };
    }
}

const game = new JigsawGame();
</script>
</body>
</html>