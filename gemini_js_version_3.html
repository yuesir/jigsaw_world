<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>经典窄颈圆头拼图实现</title>
    <style>
        body { background: #1a1a1a; color: white; font-family: sans-serif; display: flex; flex-direction: column; align-items: center; }
        canvas { background: #333; box-shadow: 0 0 30px rgba(0,0,0,0.7); cursor: grab; margin-top: 20px; border-radius: 4px; }
        .controls { background: #222; padding: 15px; border-radius: 8px; margin-top: 20px; display: flex; gap: 10px; align-items: center; }
        button { padding: 10px 20px; cursor: pointer; background: #27ae60; color: white; border: none; border-radius: 4px; font-weight: bold; }
        button:hover { background: #2ecc71; }
        select { padding: 5px; border-radius: 4px; }
    </style>
</head>
<body>

    <h2>经典拼图形状生成器</h2>
    <div class="controls">
        <label>难度: <select id="gridSize">
            <option value="3">3x3 (简单)</option>
            <option value="4" selected>4x4 (标准)</option>
            <option value="5">5x5 (困难)</option>
        </select></label>
        <button onclick="game.shuffle()">随机打乱</button>
        <button onclick="game.reset()">重置网格</button>
    </div>

    <canvas id="puzzleCanvas"></canvas>

<script>
/**
 * 基于 Bézier 曲线数学实现的经典拼图逻辑 
 */
class JigsawGame {
    constructor() {
        this.canvas = document.getElementById('puzzleCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.img = new Image();
        this.pieces = [];
        this.selected = null;
        
        this.img.onload = () => this.reset();
        // 示例图片
        this.img.src = 'https://images.unsplash.com/photo-1506744038136-46273834b3fb?auto=format&fit=crop&w=800&q=80';

        this.canvas.onmousedown = (e) => this.handleDown(e);
        window.onmousemove = (e) => this.handleMove(e);
        window.onmouseup = () => this.handleUp();
    }

    reset() {
        const size = parseInt(document.getElementById('gridSize').value);
        this.cols = size;
        this.rows = size;

        const maxW = window.innerWidth * 0.8;
        const scale = Math.min(1, maxW / this.img.width);
        this.canvas.width = this.img.width * scale;
        this.canvas.height = this.img.height * scale;

        this.pw = this.canvas.width / this.cols;
        this.ph = this.canvas.height / this.rows;

        this.generatePieces();
        this.draw();
    }

    generatePieces() {
        this.pieces = [];
        // 预生成所有边的凹凸状态 (0: 平, 1: 凸, -1: 凹)
        const vEdges = Array(this.cols + 1).fill(0).map(() => Array(this.rows).fill(0));
        const hEdges = Array(this.rows + 1).fill(0).map(() => Array(this.cols).fill(0));

        for (let i = 1; i < this.cols; i++) 
            for (let j = 0; j < this.rows; j++) vEdges[i][j] = Math.random() > 0.5 ? 1 : -1;
        for (let j = 1; j < this.rows; j++) 
            for (let i = 0; i < this.cols; i++) hEdges[j][i] = Math.random() > 0.5 ? 1 : -1;

        for (let r = 0; r < this.rows; r++) {
            for (let c = 0; c < this.cols; c++) {
                this.pieces.push({
                    c, r,
                    x: c * this.pw, y: r * this.ph,
                    correctX: c * this.pw, correctY: r * this.ph,
                    // 四边形状：上、右、下、左 (由相邻块决定)
                    edges: [hEdges[r][c], vEdges[c+1][r], hEdges[r+1][c], vEdges[c][r]],
                    locked: false
                });
            }
        }
    }

    /**
     * 关键修复：绘制窄颈圆头形状
     * @param {number} L 边缘总长度
     * @param {number} dir 方向 (1为外凸, -1为内凹, 0为平)
     */
    drawBulbousTab(ctx, L, dir) {
        if (dir === 0) {
            ctx.lineTo(L, 0);
            return;
        }

        const tabH = L * 0.22; // 凸起高度系数
        const h = tabH * dir;
        
        // 定义五个关键水平点比例
        const p1 = L * 0.35; // 颈部起点
        const p2 = L * 0.40; // 窄颈最深处
        const p3 = L * 0.50; // 圆头顶端中心
        const p4 = L * 0.60; // 窄颈返回处
        const p5 = L * 0.65; // 颈部终点

        ctx.lineTo(p1, 0);

        // 第一段：从直线平滑弯入颈部
        ctx.bezierCurveTo(p1 + L*0.02, h * 0.05, p2, h * 0.20, p2, h * 0.45);
        
        // 第二段：绘制丰满的圆头 (控制点横向拉宽，纵向拉高)
        ctx.bezierCurveTo(p2, h * 1.35, p4, h * 1.35, p4, h * 0.45);

        // 第三段：从颈部平滑回到直线
        ctx.bezierCurveTo(p4, h * 0.20, p5 - L*0.02, h * 0.05, p5, 0);

        ctx.lineTo(L, 0);
    }

    drawPiecePath(ctx, piece) {
        ctx.beginPath();
        ctx.moveTo(0, 0);

        // Top (注意：对于当前块，上边的凹凸应与上方块的下边相反，故加负号)
        this.drawBulbousTab(ctx, this.pw, -piece.edges[0]);

        // Right
        ctx.save();
        ctx.translate(this.pw, 0); ctx.rotate(Math.PI / 2);
        this.drawBulbousTab(ctx, this.ph, piece.edges[1]);
        ctx.restore();

        // Bottom
        ctx.save();
        ctx.translate(this.pw, this.ph); ctx.rotate(Math.PI);
        this.drawBulbousTab(ctx, this.pw, piece.edges[2]);
        ctx.restore();

        // Left
        ctx.save();
        ctx.translate(0, this.ph); ctx.rotate(-Math.PI / 2);
        this.drawBulbousTab(ctx, this.ph, -piece.edges[3]);
        ctx.restore();

        ctx.closePath();
    }

    draw() {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        
        // 渲染列表排序
        const renderList = [...this.pieces].sort((a,b) => (a === this.selected ? 1 : (a.locked ? -1 : 0)));

        renderList.forEach(p => {
            this.ctx.save();
            this.ctx.translate(p.x, p.y);

            this.drawPiecePath(this.ctx, p);
            
            this.ctx.save();
            this.ctx.clip(); // 裁剪出圆头形状 [cite: 20]

            // 计算出血位 (Bleed) 以补偿圆头部分的图像显示 [cite: 21]
            const bleed = this.pw * 0.35;
            const imgScale = this.img.width / this.canvas.width;

            this.ctx.drawImage(
                this.img,
                (p.correctX - bleed) * imgScale, (p.correctY - bleed) * imgScale,
                (this.pw + bleed * 2) * imgScale, (this.ph + bleed * 2) * imgScale,
                -bleed, -bleed, this.pw + bleed * 2, this.ph + bleed * 2
            );
            this.ctx.restore();

            // 绘制描边增强真实感
            this.ctx.strokeStyle = p.locked ? "rgba(255,255,255,0.15)" : "rgba(255,255,255,0.7)";
            this.ctx.lineWidth = 1.5;
            this.ctx.stroke();
            this.ctx.restore();
        });
    }

    shuffle() {
        this.pieces.forEach(p => {
            p.x = Math.random() * (this.canvas.width - this.pw);
            p.y = Math.random() * (this.canvas.height - this.ph);
            p.locked = false;
        });
        this.draw();
    }

    handleDown(e) {
        const rect = this.canvas.getBoundingClientRect();
        const mx = e.clientX - rect.left, my = e.clientY - rect.top;
        for (let i = this.pieces.length - 1; i >= 0; i--) {
            const p = this.pieces[i];
            if (p.locked) continue;
            // 简单的边界检测
            if (mx > p.x && mx < p.x + this.pw && my > p.y && my < p.y + this.ph) {
                this.selected = p;
                this.dragOffX = mx - p.x;
                this.dragOffY = my - p.y;
                break;
            }
        }
    }

    handleMove(e) {
        if (!this.selected) return;
        const rect = this.canvas.getBoundingClientRect();
        this.selected.x = e.clientX - rect.left - this.dragOffX;
        this.selected.y = e.clientY - rect.top - this.dragOffY;
        this.draw();
    }

    handleUp() {
        if (!this.selected) return;
        const d = Math.sqrt(Math.pow(this.selected.x - this.selected.correctX, 2) + Math.pow(this.selected.y - this.selected.correctY, 2));
        if (d < 25) { // 磁吸效果 [cite: 23]
            this.selected.x = this.selected.correctX;
            this.selected.y = this.selected.correctY;
            this.selected.locked = true;
        }
        this.selected = null;
        this.draw();
    }
}

const game = new JigsawGame();
</script>
</body>
</html>