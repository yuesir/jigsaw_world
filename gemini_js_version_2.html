<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>经典拼图形状实现 - 贝塞尔曲线版</title>
    <style>
        body { background: #1a1a1a; color: white; font-family: sans-serif; display: flex; flex-direction: column; align-items: center; }
        canvas { background: #333; box-shadow: 0 0 20px black; cursor: grab; margin-top: 20px; }
        .controls { background: #222; padding: 15px; border-radius: 8px; margin-top: 20px; display: flex; gap: 10px; }
        button { padding: 8px 15px; cursor: pointer; background: #444; color: white; border: 1px solid #666; font-weight: bold; }
        button:hover { background: #555; }
    </style>
</head>
<body>

    <h2>经典拼图形状实现</h2>
    <div class="controls">
        <label>难度: <select id="gridSize">
            <option value="3">3x3</option>
            <option value="4" selected>4x4</option>
            <option value="5">5x5</option>
        </select></label>
        <button onclick="game.shuffle()">打乱拼图</button>
        <button onclick="game.reset()">重新生成</button>
    </div>

    <canvas id="puzzleCanvas"></canvas>

<script>
/**
 * 基于 Bézier 曲线数学实现的拼图逻辑 
 */
class JigsawGame {
    constructor() {
        this.canvas = document.getElementById('puzzleCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.img = new Image();
        this.pieces = [];
        this.selected = null;
        
        this.img.onload = () => this.reset();
        // 使用高质量风景图
        this.img.src = 'https://images.unsplash.com/photo-1464822759023-fed622ff2c3b?auto=format&fit=crop&w=800&q=80';

        this.canvas.onmousedown = (e) => this.handleDown(e);
        window.onmousemove = (e) => this.handleMove(e);
        window.onmouseup = () => this.handleUp();
    }

    reset() {
        const size = parseInt(document.getElementById('gridSize').value);
        this.cols = size;
        this.rows = size;

        const maxW = window.innerWidth * 0.8;
        const scale = Math.min(1, maxW / this.img.width);
        this.canvas.width = this.img.width * scale;
        this.canvas.height = this.img.height * scale;

        this.pw = this.canvas.width / this.cols;
        this.ph = this.canvas.height / this.rows;

        this.generatePieces();
        this.draw();
    }

    /**
     * 过程化生成互锁碎片形状 [cite: 22]
     */
    generatePieces() {
        this.pieces = [];
        const vEdges = Array(this.cols + 1).fill(0).map(() => Array(this.rows).fill(0));
        const hEdges = Array(this.rows + 1).fill(0).map(() => Array(this.cols).fill(0));

        // 随机生成内部边的凹凸方向 (1=凸, -1=凹, 0=平)
        for (let i = 1; i < this.cols; i++) 
            for (let j = 0; j < this.rows; j++) vEdges[i][j] = Math.random() > 0.5 ? 1 : -1;
        for (let j = 1; j < this.rows; j++) 
            for (let i = 0; i < this.cols; i++) hEdges[j][i] = Math.random() > 0.5 ? 1 : -1;

        for (let r = 0; r < this.rows; r++) {
            for (let c = 0; c < this.cols; c++) {
                this.pieces.push({
                    c, r,
                    x: c * this.pw, y: r * this.ph,
                    correctX: c * this.pw, correctY: r * this.ph,
                    // 存储四边形状：上、右、下、左
                    edges: [hEdges[r][c], vEdges[c+1][r], hEdges[r+1][c], vEdges[c][r]],
                    locked: false
                });
            }
        }
    }

    /**
     * 核心绘制逻辑：实现颈部缩窄、头部圆润的贝塞尔曲线
     * @param {number} L 边缘长度
     * @param {number} H 凸起高度系数
     * @param {number} dir 方向 (1=外凸, -1=内凹, 0=平)
     */
    drawClassicTab(ctx, L, H, dir) {
        if (dir === 0) {
            ctx.lineTo(L, 0);
            return;
        }

        const absH = H * dir;
        // 定义关键点比例
        const p1 = L * 0.35; // 颈部起点
        const p2 = L * 0.42; // 窄颈位置
        const p3 = L * 0.50; // 圆头中心
        const p4 = L * 0.58; // 窄颈对称点
        const p5 = L * 0.65; // 颈部终点

        ctx.lineTo(p1, 0);

        // 曲线1：从边缘进入窄颈
        ctx.bezierCurveTo(p1, absH * 0.1, p2, absH * 0.2, p2, absH * 0.4);
        
        // 曲线2：从窄颈绕过圆头
        ctx.bezierCurveTo(p2, absH * 0.9, p3, absH * 1.15, p3, absH * 1.15);
        ctx.bezierCurveTo(p3, absH * 1.15, p4, absH * 0.9, p4, absH * 0.4);

        // 曲线3：从窄颈回到边缘
        ctx.bezierCurveTo(p4, absH * 0.2, p5, absH * 0.1, p5, 0);

        ctx.lineTo(L, 0);
    }

    drawPiecePath(ctx, piece) {
        const hSize = this.pw * 0.2; // 凸起高度基于宽度
        ctx.beginPath();
        ctx.moveTo(0, 0);

        // 上边缘 (Top)
        this.drawClassicTab(ctx, this.pw, hSize, -piece.edges[0]);

        // 右边缘 (Right)
        ctx.save();
        ctx.translate(this.pw, 0); ctx.rotate(Math.PI / 2);
        this.drawClassicTab(ctx, this.ph, hSize, piece.edges[1]);
        ctx.restore();

        // 下边缘 (Bottom)
        ctx.save();
        ctx.translate(this.pw, this.ph); ctx.rotate(Math.PI);
        this.drawClassicTab(ctx, this.pw, hSize, piece.edges[2]);
        ctx.restore();

        // 左边缘 (Left)
        ctx.save();
        ctx.translate(0, this.ph); ctx.rotate(-Math.PI / 2);
        this.drawClassicTab(ctx, this.ph, hSize, -piece.edges[3]);
        ctx.restore();

        ctx.closePath();
    }

    draw() {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        // 背景底色
        this.ctx.fillStyle = "#111";
        this.ctx.fillRect(0,0,this.canvas.width,this.canvas.height);

        // 渲染列表：已锁定的在底层，选中的在最顶层
        const renderList = [...this.pieces].sort((a,b) => {
            if (a === this.selected) return 1;
            if (b === this.selected) return -1;
            return a.locked ? -1 : 0;
        });

        renderList.forEach(p => {
            this.ctx.save();
            this.ctx.translate(p.x, p.y);

            this.drawPiecePath(this.ctx, p);
            
            this.ctx.save();
            this.ctx.clip(); // 裁剪形状 

            // 关键：计算“出血位”偏移，确保圆头图像完整
            const bleed = this.pw * 0.3;
            const sX = (p.correctX - bleed) * (this.img.width / this.canvas.width);
            const sY = (p.correctY - bleed) * (this.img.height / this.canvas.height);
            const sW = (this.pw + bleed * 2) * (this.img.width / this.canvas.width);
            const sH = (this.ph + bleed * 2) * (this.img.height / this.canvas.height);

            this.ctx.drawImage(this.img, sX, sY, sW, sH, -bleed, -bleed, this.pw + bleed * 2, this.ph + bleed * 2);
            this.ctx.restore();

            // 绘制描边增强质感
            this.ctx.strokeStyle = p.locked ? "rgba(255,255,255,0.1)" : "rgba(255,255,255,0.6)";
            this.ctx.lineWidth = 1.5;
            this.ctx.stroke();
            this.ctx.restore();
        });
    }

    shuffle() {
        this.pieces.forEach(p => {
            p.x = Math.random() * (this.canvas.width - this.pw);
            p.y = Math.random() * (this.canvas.height - this.ph);
            p.locked = false;
        });
        this.draw();
    }

    handleDown(e) {
        const rect = this.canvas.getBoundingClientRect();
        const mx = e.clientX - rect.left, my = e.clientY - rect.top;
        for (let i = this.pieces.length - 1; i >= 0; i--) {
            const p = this.pieces[i];
            if (p.locked) continue;
            // 简单的命中检测
            if (mx > p.x && mx < p.x + this.pw && my > p.y && my < p.y + this.ph) {
                this.selected = p;
                this.dragOffX = mx - p.x;
                this.dragOffY = my - p.y;
                break;
            }
        }
    }

    handleMove(e) {
        if (!this.selected) return;
        const rect = this.canvas.getBoundingClientRect();
        this.selected.x = e.clientX - rect.left - this.dragOffX;
        this.selected.y = e.clientY - rect.top - this.dragOffY;
        this.draw();
    }

    handleUp() {
        if (!this.selected) return;
        // 吸附逻辑 [cite: 23]
        const d = Math.sqrt(Math.pow(this.selected.x - this.selected.correctX, 2) + Math.pow(this.selected.y - this.selected.correctY, 2));
        if (d < 25) {
            this.selected.x = this.selected.correctX;
            this.selected.y = this.selected.correctY;
            this.selected.locked = true;
        }
        this.selected = null;
        this.draw();
    }
}

const game = new JigsawGame();
</script>
</body>
</html>