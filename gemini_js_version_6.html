<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>完美匹配拼图 - 边缘共享版</title>
    <style>
        body { background: #1a1a1a; display: flex; flex-direction: column; align-items: center; margin: 0; padding: 20px; font-family: sans-serif; color: white; }
        .controls { margin-bottom: 20px; }
        canvas { background: #000; box-shadow: 0 0 40px rgba(0,0,0,0.8); border: 2px solid #333; cursor: crosshair; }
        button { padding: 10px 20px; background: #444; color: white; border: none; border-radius: 5px; cursor: pointer; }
        button:hover { background: #666; }
    </style>
</head>
<body>
    <div class="controls">
        <button onclick="game.init()">重新开始</button>
        <button onclick="game.shuffle()">打乱拼图</button>
    </div>
    <canvas id="puzzleCanvas"></canvas>

<script>
/**
 * 边缘数据存储：预先计算并存储每一条分割线的贝塞尔形状
 */
class EdgeData {
    constructor(length) {
        this.length = length;
        this.isTab = Math.random() > 0.5; // 随机决定初始方向
        // 梨形控制点参数（归一化 0~1）
        this.params = {
            neckW: 0.12,  // 颈部宽度
            headW: 0.28,  // 头部宽度
            headH: 0.22,  // 凸起高度
            skew: (Math.random() - 0.5) * 0.1 // 随机歪斜度，修复错位的关键
        };
    }

    // 在指定的画布路径上绘制该边缘
    // reverse: 是否反向绘制路径（用于相邻碎片）
    // flip: 是否镜像反转凸凹方向
    draw(ctx, p1, p2, reverse, flip) {
        const dx = p2.x - p1.x;
        const dy = p2.y - p1.y;
        const angle = Math.atan2(dy, dx);
        const len = Math.hypot(dx, dy);

        ctx.save();
        ctx.translate(p1.x, p1.y);
        ctx.rotate(angle);

        const s = flip ? -1 : 1;
        const { neckW, headW, headH, skew } = this.params;
        
        // 定义关键点坐标
        const mid = 0.5 + skew;
        const points = [
            { x: 0, y: 0 },
            { x: (mid - headW) * len, y: 0 }, // 起始直线段
            { x: (mid - headW) * len, y: headH * len * s }, // 头部控制点1
            { x: (mid + headW) * len, y: headH * len * s }, // 头部控制点2
            { x: (mid + headW) * len, y: 0 }, // 结束直线段
            { x: len, y: 0 }
        ];

        if (!reverse) {
            ctx.lineTo(points[1].x, points[1].y);
            ctx.bezierCurveTo(points[2].x, points[2].y, points[3].x, points[3].y, points[4].x, points[4].y);
            ctx.lineTo(points[5].x, points[5].y);
        } else {
            // 反向绘制：必须严格对称，确保物理路径重合
            ctx.translate(len, 0);
            ctx.rotate(Math.PI);
            ctx.lineTo(len - points[4].x, points[4].y); 
            ctx.bezierCurveTo(len - points[3].x, points[3].y, len - points[2].x, points[2].y, len - points[1].x, points[1].y);
            ctx.lineTo(len, 0);
        }
        ctx.restore();
    }
}

class JigsawGame {
    constructor() {
        this.canvas = document.getElementById('puzzleCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.img = new Image();
        this.img.crossOrigin = "anonymous";
        // 使用您截图中的风景图类似的高质量图
        this.img.src = 'https://images.unsplash.com/photo-1464822759023-fed622ff2c3b?auto=format&fit=crop&w=1200&q=80';
        this.img.onload = () => this.init();
        
        this.cols = 4;
        this.rows = 3;
        this.pieces = [];
        this.hEdges = []; // 横向边数据库
        this.vEdges = []; // 纵向边数据库
    }

    init() {
        const ratio = this.img.width / this.img.height;
        this.canvas.width = 1000;
        this.canvas.height = 1000 / ratio;
        this.pw = this.canvas.width / this.cols;
        this.ph = this.canvas.height / this.rows;

        // 1. 生成全局唯一的边缘数据库 [cite: 22]
        for (let r = 0; r <= this.rows; r++) {
            this.hEdges[r] = [];
            for (let c = 0; c < this.cols; c++) this.hEdges[r][c] = new EdgeData(this.pw);
        }
        for (let c = 0; c <= this.cols; c++) {
            this.vEdges[c] = [];
            for (let r = 0; r < this.rows; r++) this.vEdges[c][r] = new EdgeData(this.ph);
        }

        // 2. 创建拼图块
        this.pieces = [];
        for (let r = 0; r < this.rows; r++) {
            for (let c = 0; c < this.cols; c++) {
                this.pieces.push({
                    c, r,
                    x: c * this.pw, y: r * this.ph,
                    tx: c * this.pw, ty: r * this.ph, // 目标位置
                    isLocked: false
                });
            }
        }
        this.draw();
        this.setupEvents();
    }

    // 绘制单个碎片的路径：核心逻辑是调用全局 EdgeData
    createPiecePath(ctx, piece) {
        const { c, r } = piece;
        const w = this.pw;
        const h = this.ph;

        ctx.beginPath();
        ctx.moveTo(0, 0);

        // 顶边：读取 hEdges[r][c]
        if (r === 0) ctx.lineTo(w, 0);
        else this.hEdges[r][c].draw(ctx, {x:0,y:0}, {x:w,y:0}, false, true);

        // 右边：读取 vEdges[c+1][r]
        if (c === this.cols - 1) ctx.lineTo(w, h);
        else this.vEdges[c+1][r].draw(ctx, {x:w,y:0}, {x:w,y:h}, false, false);

        // 底边：读取 hEdges[r+1][c]
        if (r === this.rows - 1) ctx.lineTo(0, h);
        else this.hEdges[r+1][c].draw(ctx, {x:w,y:h}, {x:0,y:h}, false, false);

        // 左边：读取 vEdges[c][r]
        if (c === 0) ctx.lineTo(0, 0);
        else this.vEdges[c][r].draw(ctx, {x:0,y:h}, {x:0,y:0}, false, true);

        ctx.closePath();
    }

    draw() {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        
        this.pieces.forEach(p => {
            this.ctx.save();
            this.ctx.translate(p.x, p.y);

            // 绘制裁剪路径
            this.createPiecePath(this.ctx, p);
            
            // 解决“黑月牙”的关键点：增加 1 像素的填充扩展 (Bleeding)
            // 这能防止抗锯齿产生的接缝空隙
            this.ctx.strokeStyle = "white";
            this.ctx.lineWidth = 0.5;
            this.ctx.stroke(); 
            
            this.ctx.clip();

            // 映射图片：精确计算裁剪区域，解决“形状不正确”的偏移问题
            const imgScale = this.img.width / this.canvas.width;
            // 稍微扩大绘制区域 (1px) 消除白边
            const bleed = 1; 
            this.ctx.drawImage(
                this.img,
                p.c * this.pw * imgScale, p.r * this.ph * imgScale, 
                this.pw * imgScale, this.ph * imgScale,
                -bleed, -bleed, this.pw + bleed*2, this.ph + bleed*2
            );

            this.ctx.restore();
            
            // 绘制描边增强视觉效果
            this.ctx.save();
            this.ctx.translate(p.x, p.y);
            this.createPiecePath(this.ctx, p);
            this.ctx.lineWidth = 1;
            this.ctx.strokeStyle = p.isLocked ? "rgba(255,255,255,0.1)" : "rgba(255,255,255,0.4)";
            this.ctx.stroke();
            this.ctx.restore();
        });
    }

    shuffle() {
        this.pieces.forEach(p => {
            p.x = Math.random() * (this.canvas.width - this.pw);
            p.y = Math.random() * (this.canvas.height - this.ph);
            p.isLocked = false;
        });
        this.draw();
    }

    setupEvents() {
        let activePiece = null;
        let offset = { x: 0, y: 0 };

        this.canvas.onmousedown = (e) => {
            const rect = this.canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            // 逆序查找，优先选中顶层碎片
            for (let i = this.pieces.length - 1; i >= 0; i--) {
                const p = this.pieces[i];
                if (p.isLocked) continue;
                if (mouseX > p.x && mouseX < p.x + this.pw && mouseY > p.y && mouseY < p.y + this.ph) {
                    activePiece = p;
                    offset.x = mouseX - p.x;
                    offset.y = mouseY - p.y;
                    // 将选中的移动到数组末尾以实现在顶层绘制
                    this.pieces.push(this.pieces.splice(i, 1)[0]);
                    break;
                }
            }
        };

        window.onmousemove = (e) => {
            if (!activePiece) return;
            const rect = this.canvas.getBoundingClientRect();
            activePiece.x = e.clientX - rect.left - offset.x;
            activePiece.y = e.clientY - rect.top - offset.y;
            this.draw();
        };

        window.onmouseup = () => {
            if (!activePiece) return;
            // 吸附判定
            const dist = Math.hypot(activePiece.x - activePiece.tx, activePiece.y - activePiece.ty);
            if (dist < 25) {
                activePiece.x = activePiece.tx;
                activePiece.y = activePiece.ty;
                activePiece.isLocked = true;
            }
            activePiece = null;
            this.draw();
        };
    }
}

const game = new JigsawGame();
</script>
</body>
</html>